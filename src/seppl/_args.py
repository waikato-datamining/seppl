import copy
import logging
import shlex
import traceback

from typing import List, Dict, Tuple, Iterable, Set, Optional
from ._plugin import Plugin, SkippablePlugin


def escape_args(args: List[str]) -> List[str]:
    """
    Escapes any unicode characters in the arguments.

    :param args: the arguments to process
    :type args: list
    :return: the (potentially) updated arguments
    :rtype: list
    """
    result = []
    for arg in args:
        result.append(arg.encode("unicode_escape").decode())
    return result


def unescape_args(args: List[str]) -> List[str]:
    """
    Unescapes unicode characters in the arguments.

    :param args: the arguments to process
    :type args: list
    :return: the (potentially) updated arguments
    :rtype: list
    """
    result = []
    for arg in args:
        result.append(arg.encode().decode("unicode_escape"))
    return result


def split_cmdline(cmdline: str, unescape: bool = False) -> List[str]:
    """
    Splits the command-line into arguments.

    :param cmdline: the commandline to split
    :type cmdline: str
    :param unescape: whether to unescape unicode chars
    :type unescape: bool
    :return: the list of arguments
    :rtype: list
    """
    result = shlex.split(cmdline)
    if unescape:
        result = unescape_args(result)
    return result


def resolve_handler(search: str, handlers: Set[str], partial: bool = False) -> Optional[str]:
    """
    Tries to find the "search" string among the handlers, exact and partial match.

    :param search: the potential handler to find
    :type search: str
    :param handlers: the set of valid handlers to match against
    :type handlers: set
    :param partial: whether to allow partial matches
    :type partial: bool
    :return: the match or None if failed to find
    :rtype: str or None
    """
    # exact match?
    if search in handlers:
        return search

    if partial:
        # unique partial match?
        matches = []
        for handler in handlers:
            if handler.startswith(search):
                matches.append(handler)
        if len(matches) == 1:
            return matches[0]

    # nothing found
    return None


def split_args(args: List[str], handlers: List[str], unescape: bool = False, partial: bool = False) -> Dict[str, List[str]]:
    """
    Splits the command-line arguments into handler and their associated arguments.
    Special entry "" is used for global options.

    :param args: the command-line arguments to split
    :type args: list
    :param handlers: the list of valid handler names
    :type handlers: list
    :param unescape: whether to unescape unicode chars
    :type unescape: bool
    :param partial: whether to allow partial matches (may interfere with options, so use carefully)
    :type partial: bool
    :return: the dictionary for handler index / handler name + options list
    :rtype: dict
    """
    handlers_set = set(handlers)
    result = dict()
    last_handler = ""
    last_args = []

    if unescape:
        args = unescape_args(args)

    for arg in args:
        handler = resolve_handler(arg, handlers_set, partial=partial)
        if handler is not None:
            if len(last_handler) > 0:
                result[str(len(result))] = last_args
            else:
                result[""] = last_args
            last_handler = handler
            last_args = [handler]
            continue
        else:
            last_args.append(arg)

    if len(last_args) > 0:
        result[str(len(result))] = last_args

    return result


def args_to_objects(args: Dict[str, List[str]], valid_plugins: Dict[str, Plugin], allow_global_options: bool = False,
                    allow_unknown_args: bool = False, unescape: bool = False) -> List[Plugin]:
    """
    Instantiates the plugins from the parsed arguments dictionary.
    Automatically removes SkippablePlugin instances that are to be skipped.

    :param args: the arguments dictionary generated by split_args
    :type args: dict
    :param valid_plugins: the dictionary of valid plugins to use as templates
    :type valid_plugins: dict
    :param allow_global_options: whether global options are allowed (ie options that don't follow a plugin name)
    :type allow_global_options: bool
    :param allow_unknown_args: whether to allow unknown args (eg typos or unknown plugins)
    :type allow_unknown_args: bool
    :param unescape: whether to unescape unicode chars
    :type unescape: bool
    :return: the list of instantiated plugins
    :rtype: list
    """
    valid_plugins_set = set(valid_plugins.keys())
    result = []
    for key in args:
        if key == "":
            if (not allow_global_options) and (len(args[""]) > 0):
                raise Exception("No global options allowed (found: %s)!" % str(args[""]))
            else:
                continue

        name = resolve_handler(args[key][0], valid_plugins_set, partial=False)
        if name is None:
            raise Exception("Unknown plugin: %s" % args[key][0])
        plugin = copy.deepcopy(valid_plugins[name])
        sub_args = args[key][1:]
        if unescape:
            sub_args = unescape_args(sub_args)
        unknown = plugin.parse_args(sub_args)
        if not allow_unknown_args and (len(unknown) > 0):
            raise Exception("Found unknown argument(s) for plugin '%s': %s" % (plugin.name(), str(unknown)))
        result.append(plugin)

    # remove plugins to be skipped
    i = 0
    while i < len(result):
        try:
            if isinstance(result[i], SkippablePlugin) and result[i].is_skipped:
                result.pop(i)
                continue
        except:
            pass
        i += 1

    return result


def is_help_requested(args: List[str], handlers: List[str] = None, partial: bool = False) -> Tuple[bool, bool, str]:
    """
    Checks whether help was requested.

    :param args: the arguments to check
    :type args: list
    :param handlers: the list of valid handler names
    :type handlers: list
    :param partial: whether to allow partial matches (may interfere with options, so use carefully)
    :type partial: bool
    :return: the tuple of help requested: (help_requested, plugin_details, plugin_name)
    :rtype: tuple
    """
    help_requested = False
    plugin_details = False
    determine_plugin_name = False
    plugin_name = None
    for index, arg in enumerate(args):
        if (arg == "-h") or (arg == "--help"):
            help_requested = True
            determine_plugin_name = True
            break
        if arg == "--help-all":
            help_requested = True
            plugin_details = True
            break
        if arg == "--help-plugin":
            help_requested = True
            if index < len(args) - 1:
                plugin_name = args[index + 1]
            break

    # check whether for specific plugin
    if determine_plugin_name and (handlers is not None):
        handlers_set = set(handlers)
        parts = split_args(args, handlers, unescape=False, partial=partial)
        for k in parts:
            # global help request?
            if len(k) == 0:
                if ("-h" in parts[k]) or ("--help" in parts[k]):
                    break
            # skip part with just a single option (we need at least plugin_name + help_flag)
            if len(parts[k]) < 2:
                continue
            # is help flag present in options and after a plugin name (ie not at first position)?
            sub_parts = parts[k][1:]
            if ("-h" in sub_parts) or ("--help" in sub_parts):
                name = resolve_handler(parts[k][0], handlers_set, partial=partial)
                if name is not None:
                    plugin_name = name
                    break

    return help_requested, plugin_details, plugin_name


def enumerate_plugins(plugins: Iterable[str], aliases: List[str] = None, alias_flag: str = "*", prefix: str = "", width: int = 72) -> str:
    """
    Turns the list of plugin names into a string.

    :param plugins: the plugin names to turn into a string
    :type plugins: Iterable
    :param aliases: the list of known aliases (for flagging them in the generated list)
    :type aliases: list
    :param alias_flag: the string to use for identifying aliases
    :type alias_flag: str
    :param prefix: the prefix string to use for each line
    :type prefix: str
    :param width: the maximum width of the string before adding a newline
    :type width: int
    :return: the generated string
    :rtype: str
    """
    result = []
    line = prefix
    for plugin in sorted(plugins):
        if (len(line) > 0) and (line[-1] != " "):
            line += ", "
        if len(line) + len(plugin) >= width:
            result.append(line)
            line = prefix + plugin
        else:
            line += plugin
        if aliases is not None:
            if plugin in aliases:
                line += alias_flag

    if len(line) > 0:
        result.append(line)
    return "\n".join(result)


def load_args(path: str, logger: logging.Logger = None) -> List[str]:
    """
    Loads the arguments from the specified file.

    :param path: the file containing the arguments
    :type path: str
    :param logger: the logger instance to use, ignored if None
    :type logger: logging.Logger
    :return: the individual arguments
    :rtype: list
    """
    msg = "Loading pipeline from: %s" % path
    if logger is not None:
        logger.info("Loading pipeline from: %s" % path)
    else:
        print(msg)

    with open(path, "r") as fp:
        lines = fp.readlines()
    lines = [x.strip() for x in lines]
    result = split_cmdline(" ".join(lines))

    return result


def save_args(args: List[str], path: str, prog: str = None, handlers: List[str] = None, logger: logging.Logger = None) -> bool:
    """
    Saves the arguments to the specified file.

    :param args: the arguments to save
    :type args: list
    :param path: the file to save the arguments to
    :type path: str
    :param prog: the executable to prefix the arguments with, ignore if None
    :type prog: str
    :param handlers: the handlers for grouping the arguments by handler and making it more readable, uses simple format if None
    :type handlers: list
    :param logger: the logger instance to use for outputting information, ignored if None
    :type logger: logging.Logger
    :return: whether successfully saved
    :rtype: bool
    """
    try:
        msg = "Saving arguments to: %s" % path
        if logger is not None:
            logger.info(msg)
        else:
            print(msg)

        if handlers is not None:
            split = split_args(args, handlers)
            with open(path, "w") as fp:
                if prog is not None:
                    fp.write(prog + "\n")
                for group in split:
                    sub_args = split[group]
                    # global options (ie group=="")?
                    if len(group) == 0:
                        for sub_arg in sub_args:
                            fp.write("    " + sub_arg + "\n")
                    else:
                        # if not global options then don't indent 1st arg (ie plugin name)
                        fp.write(sub_args[0] + "\n")
                        sub_args = sub_args[1:]
                        for sub_arg in sub_args:
                            fp.write("    " + sub_arg + "\n")
        else:
            with open(path, "w") as fp:
                if prog is not None:
                    fp.write(prog + "\n")
                fp.write("\n".join(args))

        return True
    except:
        msg = "Failed to save arguments in: %s" % path
        if logger is not None:
            logger.error(msg, exc_info=True)
        else:
            print(msg)
            traceback.print_exc()
        return False
